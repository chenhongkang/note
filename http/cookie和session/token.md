# token

### 解决问题

session Id存放在服务器中，随着服务器机器的增多，管理起来比较麻烦（可以做一个类似vuex的统一sessionId数据管理工具）

也可以使用cookie来解决

### 原理

用户登录后获取，加密密钥，之后用户发送的请求时，将body内容结合密钥，经过一部分加密流程进行加密，放入header中

浏览器使用密钥，根据body中的数据执行相同的流程，对比token是否一样

<font color='red'>密钥和加密流程都是可以被第三方获取的，所以还是有风险</font>

<font color='red'>这样解决了session id的存放问题，服务器只需要通过token校验就知道用户是否登录</font>

### 单点登录

1. 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
2. sso认证中心发现用户未登录，将用户引导至登录页面
3. 用户输入用户名密码提交登录申请
4. sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
5. sso认证中心带着令牌跳转会最初的请求地址（系统1）
6. 系统1拿到令牌，去sso认证中心校验令牌是否有效
7. sso认证中心校验令牌，返回有效，注册系统1
8. 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
9. 用户访问系统2的受保护资源
10. 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
11. sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
12. 系统2拿到令牌，去sso认证中心校验令牌是否有效
13. sso认证中心校验令牌，返回有效，注册系统2
14. 系统2使用该令牌创建与用户的局部会话，返回受保护资源